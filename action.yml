name: 'TODO Registrar'
description: 'Find TODO comments in code and create issues in issue tracker using todo-registrar'
author: 'Aeliot-Tm'

branding:
  icon: 'check-square'
  color: 'blue'

inputs:
  check_opened:
    description: 'Check for open PRs. Values: true (exact match), like (pattern match for templates), false (skip check)'
    required: false
    default: 'true'
  config:
    description: 'Inline YAML configuration (used when config_path is not set)'
    required: false
    default: ''
  config_path:
    description: 'Path to configuration file (relative to workspace)'
    required: false
    default: ''
  env_vars:
    description: 'Environment variable names to pass to container (newline or space separated)'
    required: false
    default: ''
  new_branch_name:
    description: 'Branch name or template. Placeholders: {current}, {runner_id}, {runnerId}, {random}, {random:N}. If empty - stay on current branch'
    required: false
    default: ''
  target_branch_name:
    description: 'Target branch for pull request. If empty - use current branch'
    required: false
    default: ''
  user_email:
    description: 'Git user email for commits'
    required: false
    default: 'action@github.com'
  user_name:
    description: 'Git user name for commits'
    required: false
    default: 'GitHub Action'
  verbosity:
    description: 'Verbosity level: quiet, normal, verbose, very-verbose, debug'
    required: false
    default: 'normal'

outputs:
  current_branch:
    description: 'Current branch name'
    value: ${{ steps.branches.outputs.current_branch }}
  template_branch:
    description: 'Original template before placeholder resolution'
    value: ${{ steps.branches.outputs.template_branch }}
  new_branch:
    description: 'Resolved branch name after placeholder substitution'
    value: ${{ steps.branches.outputs.new_branch }}
  target_branch:
    description: 'Target branch for pull request'
    value: ${{ steps.branches.outputs.target_branch }}
  skipped:
    description: 'Whether processing was skipped (true/false)'
    value: ${{ steps.check_prs.outputs.skip_processing || 'false' }}
  has_changes:
    description: 'Whether there were changes to commit (true/false)'
    value: ${{ steps.commit.outputs.has_changes || 'false' }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [[ -z "${{ inputs.config_path }}" && -z "${{ inputs.config }}" ]]; then
          echo "::error::Either 'config_path' or 'config' input must be provided"
          exit 1
        fi

    - name: Map verbosity to flag
      id: verbosity
      shell: bash
      run: |
        VERBOSITY="${{ inputs.verbosity }}"
        VERBOSITY="${VERBOSITY:-normal}"

        case "$VERBOSITY" in
          quiet)
            echo "flag=-q" >> $GITHUB_OUTPUT
            ;;
          normal)
            echo "flag=" >> $GITHUB_OUTPUT
            ;;
          verbose)
            echo "flag=-v" >> $GITHUB_OUTPUT
            ;;
          very-verbose)
            echo "flag=-vv" >> $GITHUB_OUTPUT
            ;;
          debug)
            echo "flag=-vvv" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "::error::Invalid verbosity level: $VERBOSITY. Valid values: quiet, normal, verbose, very-verbose, debug"
            exit 1
            ;;
        esac

    - name: Build environment flags
      id: env_flags
      shell: bash
      run: |
        ENV_FLAGS=""
        ENV_VARS="${{ inputs.env_vars }}"

        if [[ -n "$ENV_VARS" ]]; then
          # Replace newlines with spaces and split
          for VAR_NAME in $ENV_VARS; do
            # Skip empty entries
            [[ -z "$VAR_NAME" ]] && continue
            # Add -e flag for each variable
            ENV_FLAGS="$ENV_FLAGS -e $VAR_NAME"
          done
        fi

        echo "flags=$ENV_FLAGS" >> $GITHUB_OUTPUT

    - name: Determine branches for PR
      id: branches
      shell: bash
      run: |
        # Function to generate random alphanumeric string
        generate_random() {
          local length=${1:-5}
          local result=""
          # ~14% of bytes are [0-9a-z], read in chunks until we have enough
          while [[ ${#result} -lt $length ]]; do
            local chunk=$(head -c 256 /dev/urandom | tr -dc '0-9a-z')
            result="${result}${chunk}"
          done
          echo "${result:0:$length}"
        }

        TARGET_BRANCH="${{ inputs.target_branch_name }}"
        TEMPLATE_BRANCH="${{ inputs.new_branch_name }}"

        # Get current branch
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

        # Start with template
        NEW_BRANCH="$TEMPLATE_BRANCH"

        # Check for typo {curent} (single 'r') and warn - case insensitive
        shopt -s nocasematch
        if [[ "$NEW_BRANCH" =~ \{curent\} ]]; then
          echo "::warning::Typo detected: '{curent}' should be '{current}'. Processing continues with corrected value."
        fi
        shopt -u nocasematch

        # Replace {current} or {curent} (typo) with current branch - case insensitive
        NEW_BRANCH=$(echo "$NEW_BRANCH" | sed -E "s/\{curr?ent\}/$CURRENT_BRANCH/gi")

        # Replace {runner_id} or {runnerId} with github.run_id - case insensitive
        NEW_BRANCH=$(echo "$NEW_BRANCH" | sed -E "s/\{runner_?id\}/${{ github.run_id }}/gi")

        # Replace {random} or {random:N} with random string - case insensitive
        shopt -s nocasematch
        while [[ "$NEW_BRANCH" =~ \{random(:([0-9]+))?\} ]]; do
          LENGTH="${BASH_REMATCH[2]:-5}"  # Use captured length or default to 5
          RANDOM_STR=$(generate_random "$LENGTH")
          MATCH="${BASH_REMATCH[0]}"      # Full match: {random} or {random:10}
          NEW_BRANCH="${NEW_BRANCH/$MATCH/$RANDOM_STR}"
        done
        shopt -u nocasematch

        # If template was empty, use current branch
        if [[ -z "$NEW_BRANCH" ]]; then
          NEW_BRANCH="$CURRENT_BRANCH"
        fi
        if [[ -z "$TARGET_BRANCH" ]]; then
          TARGET_BRANCH="$CURRENT_BRANCH"
        fi

        echo "current_branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
        echo "template_branch=$TEMPLATE_BRANCH" >> $GITHUB_OUTPUT
        echo "new_branch=$NEW_BRANCH" >> $GITHUB_OUTPUT
        echo "target_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
        if [[ "$NEW_BRANCH" != "$TARGET_BRANCH" ]]; then
          echo "should_create_pr=true" >> $GITHUB_OUTPUT
        else
          echo "should_create_pr=false" >> $GITHUB_OUTPUT
        fi

    - name: Check for open pull requests and branch status
      id: check_prs
      if: inputs.check_opened == 'true' || inputs.check_opened == 'like'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        # Default: don't skip processing
        echo "skip_processing=false" >> $GITHUB_OUTPUT

        # Check for open PRs
        if [[ "${{ steps.branches.outputs.should_create_pr }}" == "true" ]]; then
          if [[ "${{ inputs.check_opened }}" == "like" ]]; then
            # Pattern matching mode for templates
            TEMPLATE="${{ steps.branches.outputs.template_branch }}"
            CURRENT_BRANCH="${{ steps.branches.outputs.current_branch }}"

            # If template is empty, behave like exact match
            if [[ -z "$TEMPLATE" ]]; then
              TEMPLATE="$CURRENT_BRANCH"
            fi

            # Build regex pattern from template
            # First, escape special regex characters in the template
            PATTERN=$(echo "$TEMPLATE" | sed -E 's/([.+?^${}()|[\]\\])/\\\1/g')

            # Replace {current} or {curent} (typo) with escaped current branch - case insensitive
            ESCAPED_CURRENT=$(echo "$CURRENT_BRANCH" | sed -E 's/([.+?^${}()|[\]\\])/\\\1/g')
            PATTERN=$(echo "$PATTERN" | sed -E "s/\\\{curr?ent\\\}/$ESCAPED_CURRENT/gi")

            # Replace {runner_id} or {runnerId} with [0-9]+ pattern - case insensitive
            PATTERN=$(echo "$PATTERN" | sed -E "s/\\\{runner_?id\\\}/[0-9]+/gi")

            # Replace {random} or {random:N} with [0-9a-z]+ pattern - case insensitive
            PATTERN=$(echo "$PATTERN" | sed -E "s/\\\{random(:[0-9]+)?\\\}/[0-9a-z]+/gi")

            # Get all open PRs to target branch (with pagination for large repos)
            OPEN_PR_HEADS=$(gh api --paginate \
              "repos/${{ github.repository }}/pulls" \
              -f state=open \
              -f base="${{ steps.branches.outputs.target_branch }}" \
              --jq '.[].head.ref')

            # Check if any head branch matches the pattern
            while IFS= read -r head_branch; do
              [[ -z "$head_branch" ]] && continue
              if [[ "$head_branch" =~ ^${PATTERN}$ ]]; then
                echo "skip_processing=true" >> $GITHUB_OUTPUT
                echo "::notice::Found open PR from '$head_branch' matching pattern '$TEMPLATE' to '${{ steps.branches.outputs.target_branch }}'. Skipping processing."
                exit 0
              fi
            done <<< "$OPEN_PR_HEADS"
          else
            # Exact match mode (check_opened == 'true')
            OPEN_PR=$(gh pr list --state open \
              --head "${{ steps.branches.outputs.new_branch }}" \
              --base "${{ steps.branches.outputs.target_branch }}" \
              --limit 1 \
              --json number --jq '.[0].number // empty')
            if [[ -n "$OPEN_PR" ]]; then
              echo "skip_processing=true" >> $GITHUB_OUTPUT
              echo "::notice::Found open PR #$OPEN_PR from '${{ steps.branches.outputs.new_branch }}' to '${{ steps.branches.outputs.target_branch }}'. Skipping processing."
              exit 0
            fi
          fi
        fi

        # Check if behind remote
        if [[ "${{ steps.branches.outputs.new_branch }}" != "${{ steps.branches.outputs.current_branch }}" ]]; then
          git fetch origin --quiet
          NEW_BRANCH="${{ steps.branches.outputs.new_branch }}"
          if git show-ref --verify --quiet refs/remotes/origin/$NEW_BRANCH; then
            BEHIND=$(git rev-list --count HEAD..origin/$NEW_BRANCH)
            if [[ "$BEHIND" -gt 0 ]]; then
              echo "skip_processing=true" >> $GITHUB_OUTPUT
              echo "::notice::Remote branch 'origin/$NEW_BRANCH' is $BEHIND commit(s) ahead of current HEAD. Skipping processing."
            fi
          fi
        fi

    - name: Compose config path
      id: config
      if: steps.check_prs.outputs.skip_processing != 'true'
      shell: bash
      run: |
        if [[ -n "${{ inputs.config_path }}" ]]; then
          echo "path=/code/${{ inputs.config_path }}" >> $GITHUB_OUTPUT
        else
          echo "path=STDIN" >> $GITHUB_OUTPUT
        fi

    - name: Run TODO Registrar
      if: steps.check_prs.outputs.skip_processing != 'true'
      shell: bash
      run: |
        echo '${{ inputs.config }}' | docker run --rm -i \
          -v "${{ github.workspace }}:/code" \
          ${{ steps.env_flags.outputs.flags }} \
          ghcr.io/aeliot-tm/todo-registrar:3.2.0 \
          ${{ steps.verbosity.outputs.flag }} \
          --config="${{ steps.config.outputs.path }}"

    - name: Checkout new branch
      if: steps.check_prs.outputs.skip_processing != 'true' && steps.branches.outputs.new_branch != steps.branches.outputs.current_branch
      shell: bash
      run: git checkout -b ${{ steps.branches.outputs.new_branch }} 1> /dev/null

    - name: Commit and push changes
      id: commit
      if: steps.check_prs.outputs.skip_processing != 'true'
      shell: bash
      run: |
        git config --local user.email "${{ inputs.user_email }}"
        git config --local user.name "${{ inputs.user_name }}"
        git add -A .

        if git commit -m "TODO-REGISTRAR: automated registering of new TODOs"; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
          git push origin HEAD
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "Nothing to commit" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Create pull request
      if: steps.check_prs.outputs.skip_processing != 'true' && steps.branches.outputs.should_create_pr == 'true' && steps.commit.outputs.has_changes == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        gh pr create \
          -B ${{ steps.branches.outputs.target_branch }} \
          -H ${{ steps.branches.outputs.new_branch }} \
          --title '[TODO Registrar] automated registering of new TODOs' \
          --body 'Created by Github action'
